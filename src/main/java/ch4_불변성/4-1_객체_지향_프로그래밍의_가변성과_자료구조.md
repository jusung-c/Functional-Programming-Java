
## 객체 지향 프로그래밍의 가변성과 자료 구조
객체 지향 언어인 자바에서는 객체의 상태를 가변 형태로 캡슐화하고 `setter`와 같은 메서드로 상태를 변화시킨다. 
- 이를 참조하는 다른 모든 사용자에게도 영향

**POJO vs JavaBean**

| | POJO | JavaBean |
|---|----|----|
|일반 제한| 자바 규칙에 따름| JavaBean API 사양에 따름|
|직렬화| 선택적 | java.io.Serializable 상속해야함 |
|필드 가시성| 제한 없음| private만 가능|
|필드 접근| 제한 없음 | getter와 setter를 통해서만 접근|
|생성자|제한 없음| 인수가 없는 생성자가 존재해야 함|


Collection 프레임워크같은 JDK에 있는 자료 구조들은 대부분 가변 상태와 직접 변경이 가능한 방식을 기반으로 설계되었다. 
- ex) List<E>의 add(E value)나 remove(E value)와 같은 가변 메서드는 변경이 발생했음을 나타내기 위해 boolean을 반환한다.
- Collection을 그 즉시 변경하며 이전 상태는 손실된다. 

**가변 상태의 단점**
- 복잡성과 불확실성 유발
- 가변 상태를 공유하는 것은 공유된 상태에 엑세스하는 컴포넌트의 수명을 포함해 복잡성을 증가시킨다.
- 특히 동시성 프로그래밍은 공유된 상태의 복잡성에 영향을 받으며 많은 문제가 가변성에서 발생한다.
- 갑변 상태의 경우 테스트 시 더 많이 검증해야 하므로 추가 작업이 늘어난다.


